#!/usr/bin/env perl
use v5.14.1;
use Pod::Usage;
use Getopt::Long;
use JSON::API;
use Catmandu;
use List::Util qw(any);

GetOptions( \my %opt, 'help|?', 'language|l=s', 'trust|t=s' )
  or pod2usage(2);
pod2usage( -verbose => 99, -sections => [qw(SYNOPSIS OPTIONS EXAMPLES)] )
  if $opt{help} or !@ARGV;

pod2usage("missing scheme arguments") if @ARGV < 2;
pod2usage("missing concept(s)")       if @ARGV < 3;

my %schemes = (
    NSK => {
        notation => ["NSK"],
        uri      => "http://bartoc.org/en/node/20298",
        API      => "https://coli-conc.gbv.de/api/",
    },
    BK => {
        notation => ["BK"],
        uri      => "http://bartoc.org/en/node/18785",
        API      => "http://api.dante.gbv.de/",
    },
    RVK => {
        notation => ["RVK"],
        uri      => "http://uri.gbv.de/terminology/rvk/",
        API      => "https://coli-conc.gbv.de/rvk/api/"
    },
    DDC => {
        notation => ["DDC"],
        uri      => "http://bartoc.org/en/node/241",
        API      => "https://coli-conc.gbv.de/api/"
    }
);

my %mappingTypes = (
    'http://www.w3.org/2004/02/skos/core#closeMatch'      => "≈",
    'http://www.w3.org/2004/02/skos/core#exactMatch'      => "=",
    'http://www.w3.org/2004/02/skos/core#narrowMatch'     => "<",
    'http://www.w3.org/2004/02/skos/core#broadMatch'      => ">",
    'http://www.w3.org/2004/02/skos/core#relatedMatch'    => "~",
    'http://www.w3.org/2004/02/skos/core#mappingRelation' => '→',
);

my $defaultTrust = { type => [ 'exactMatch', 'narrowMatch' ] };

my $trust =
  $opt{trust} ? Catmandu->importer( 'YAML', file => $opt{trust} )->next : undef;

my ( $from, $to ) = map { $schemes{$_} or pod2usage("unknown scheme $_") }
  map { uc $_ } splice @ARGV, 0, 2;
my @queue = @ARGV;

while (@queue) {
    my $notation = shift @queue;

    my $concept = getConcept(
        $from,
        notation   => $notation,
        properties => "narrower,ancestors"
    );
    if ($concept) {

        # if type < or type =: no narrower
        # otherwise check narrower
        my $mapped;
        my @mappings = getMappings( $from, $to, $notation, $trust );

        if (@mappings) {

            for ( my $i = 0 ; $i < @mappings ; $i++ ) {
                my $m = $mappings[$i];

                my $notation = join ' ∧ ',
                  map { $_->{notation}[0] } @{ $m->{to}{memberSet} };

                my $target = getConcept(
                    $to,
                    notation   => $notation,
                    properties => 'narrower'
                );

                $mapped = 1 if $target && !@{ $target->{narrower} };

                status( $concept, $m, $mapped, $i );
            }
        }
        else {
            status($concept);
        }

        unless ($mapped) {
            push @queue, map { $_->{notation}[0] } @{ $concept->{narrower} };
        }
    }
}

sub status {
    my ( $concept, $mapping, $mapped, $etc ) = @_;

    my $notation = $concept->{notation}[0];
    my $depth    = scalar @{ $concept->{ancestors} };
    my $width    = 50;

    if ($etc) {
        print " " x $width;
    }
    else {
        $width = $width - $depth;
        print " " x $depth;
        printf "%-${width}s", $notation;
    }

    if ($mapping) {
        my $to = join ' ∩ ',
          map { $_->{notation}[0] } @{ $mapping->{to}{memberSet} };

        my $type = $mappingTypes{ ( $mapping->{type} || [] )->[0] } || '→ ';

        print "$type $to";
        print " ✓" if $mapped;
    }
    elsif ( my $lang = $opt{language} ) {
        print $concept->{prefLabel}{$lang};
    }

    say "";
}

sub getMappings {
    my ( $from, $to, $notation, $trust ) = @_;

    my @types = map { "http://www.w3.org/2004/02/skos/core#$_" }
      @{ $trust->{type} || $defaultTrust->{type} };

    my $api      = JSON::API->new('http://coli-conc.gbv.de/api/mappings');
    my $mappings = $api->get(
        '',
        {
            from       => $notation,
            fromSchme  => $from->{uri},
            toScheme   => $to->{uri},
            properties => 'annotations,creator',
            type       => join( '|', @types ),
        }
    );

    return grep { trusted( $_, $trust ) } @$mappings;
}

# TODO: this should be moved to a library
sub trusted {
    my ( $mapping, $trust ) = @_;

    my $ann = $mapping->{annotations} || [];
    my %account = map { ($_ => 1) } @{$trust->{account} || []};

    # trust all confirmed mappings
    return 1 if any { $_->{motivation} eq 'moderating' } @$ann;

    # don't trust downvoted mappings
    # (TODO: only if downvoted by known account)
    return 0
      if any { $_->{motivation} eq 'assessing' and $_->{bodyValue} eq "-1" }
    @$ann;

    if (%account) {
        # trust mappings by known accounts
        return any { $account{$_->{uri}} } @{$mapping->{creator}||[]};
    } else {
        # trust all mappings
        return 1;
    }
}

sub getConcept {
    my ( $voc, %query ) = @_;

    die "missing notation" unless $query{notation} or $query{uri};

    my $hash = join ' ', map { ( $_, $query{$_} ) } sort keys %query;

    state %cache;
    unless ( exists $cache{$hash} ) {

        my $api = JSON::API->new( $voc->{API} );
        my $res = $api->get( 'data', { voc => $voc->{uri}, %query } );
        if ( $api->was_success && ref $res ) {
            $cache{$hash} = $res->[0];
        }
        else {
            $cache{$hash} = undef;
            my $id = $query{notation} // $query{uri};
            warn "unknown " . $voc->{notation}[0] . ": $id\n";
        }
    }

    return $cache{$hash};
}

=head1 SYNOPSIS

 mapping-status [options] <scheme> <scheme> <concept...>

=head1 OPTIONS
 
 --help|-h       this help message
 --language|-l   include label in given language if concept not mapped
 --trust|-t      YAML file to load trust rules from

=head1 EXAMPLES

 mapping-status nsk bk The -l en
 mapping-status rvk bk WE -l de
 mapping-status rvk bk WE -l de -t trusted-rvk.yaml

=cut
