#!/usr/bin/env perl
use v5.14.1;
use Pod::Usage;
use Getopt::Long;
use JSON::API;
use Catmandu;

use Cwd qw(abs_path);
use FindBin;
use lib abs_path("$FindBin::Bin/../lib");
use ColiRich;

GetOptions( \my %opt, 'help|?', 'language|l=s', 'trust|t=s', 'depth|d=i' )
  or pod2usage(2);
pod2usage( -verbose => 99, -sections => [qw(SYNOPSIS OPTIONS EXAMPLES)] )
  if $opt{help} or !@ARGV;

pod2usage("missing schemes argument") if @ARGV < 1;
pod2usage("missing concept(s)")       if @ARGV < 2;

my %schemes = (
    NSK => {
        notation => ["NSK"],
        uri      => "http://bartoc.org/en/node/20298",
        API      => "https://coli-conc.gbv.de/api/",
    },
    BK => {
        notation => ["BK"],
        uri      => "http://bartoc.org/en/node/18785",
        API      => "http://api.dante.gbv.de/",
    },
    RVK => {
        notation => ["RVK"],
        uri      => "http://uri.gbv.de/terminology/rvk/",
        API      => "https://coli-conc.gbv.de/rvk/api/"
    },
    DDC => {
        notation => ["DDC"],
        uri      => "http://bartoc.org/en/node/241",
        API      => "https://coli-conc.gbv.de/api/"
    }
);

my %mappingTypes = (
    'http://www.w3.org/2004/02/skos/core#closeMatch'      => "≈",
    'http://www.w3.org/2004/02/skos/core#exactMatch'      => "=",
    'http://www.w3.org/2004/02/skos/core#narrowMatch'     => "<",
    'http://www.w3.org/2004/02/skos/core#broadMatch'      => ">",
    'http://www.w3.org/2004/02/skos/core#relatedMatch'    => "~",
    'http://www.w3.org/2004/02/skos/core#mappingRelation' => '→',
);

my $trust =
  $opt{trust} ? Catmandu->importer( 'YAML', file => $opt{trust} )->next : {};

my ( $from, $to ) = map { $schemes{$_} or pod2usage("unknown scheme $_") }
  map { uc $_ } split /-/, shift @ARGV;
my @queue = @ARGV;

my $startDepth = -1;

while (@queue) {
    my $notation = shift @queue;

    my $concept = getConcept(
        $from,
        notation   => $notation,
        properties => "narrower,ancestors"
    );
    if ($concept) {
        my $depth = scalar @{ $concept->{ancestors} || [] };
        $startDepth = $depth if $startDepth == -1;
        
        my $children = $concept->{narrower};
        $children = undef if $children && !$children->[0];

        my $mapped;
        my @mappings = getMappings( $from, $to, $notation, $trust );

        if (@mappings) {
            
            for ( my $i = 0 ; $i < @mappings ; $i++ ) {
                my $m = $mappings[$i];

                my $notation = join ' ∧ ',
                  map { $_->{notation}[0] } @{ $m->{to}{memberSet} };

                my $target = getConcept(
                    $to,
                    notation   => $notation,
                    properties => 'narrower'
                );

                my $leaf = !$target->{narrower} || !@{$target->{narrower}};
                $mapped = 1 if $target && !( $children && !$leaf );

                status( $concept, $m, $mapped, $i );
            }
        }
        else {
            status($concept);
        }

        unless ($mapped) {

            # TODO: traverse anyway if required to do so

            next if $opt{depth} && $depth - $startDepth + 1 >= $opt{depth};
            next unless $children;
            push @queue, sort map { $_->{notation}[0] } @$children;
        }
    }
}

sub status {
    my ( $concept, $mapping, $mapped, $etc ) = @_;

    my $notation = $concept->{notation}[0];
    my $depth    = scalar @{ $concept->{ancestors} } - $startDepth;
    my $width    = 50;

    if ($etc) {
        print " " x $width;
    }
    else {
        $width = $width - $depth;
        print " " x $depth;
        printf "%-${width}s", $notation;
    }

    if ($mapping) {
        my $to = join ' ∩ ',
          map { $_->{notation}[0] } @{ $mapping->{to}{memberSet} };

        my $type = $mappingTypes{ ( $mapping->{type} || [] )->[0] } || '→ ';

        print "$type $to";
        print " ✓" if $mapped;
    }
    elsif ( my $lang = $opt{language} ) {
        print $concept->{prefLabel}{$lang};
    }

    say "";
}

=head1 SYNOPSIS

 mapping-status [options] <scheme> <scheme> <concept...>

=head1 OPTIONS
 
 --help|-h       this help message
 --language|-l   include label in given language if concept not mapped
 --depth|-d      maximum depth to traverse to with first concept at 1
 --trust|-t      YAML file to load trust rules from

=head1 EXAMPLES

 mapping-status nsk-bk The -l en
 mapping-status ddc-bk 949 -l de -d 2
 mapping-status rvk-bk WE -l de -t trusted-rvk.yaml

=cut
